/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __reflectGet = Reflect.get;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WordFrequencyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var VIEW_TYPE_WORD_FREQ = "word-frequency-list-view";
var VIEW_TYPE_WORD_NOTES = "word-notes-view";
var DEFAULT_SETTINGS = {
  hiddenWords: []
};
var WordFrequencyPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.registerView(
        VIEW_TYPE_WORD_FREQ,
        (leaf) => new WordFrequencyView(leaf, this.app.vault, this)
      );
      this.registerView(
        VIEW_TYPE_WORD_NOTES,
        (leaf) => new WordNotesView(leaf, this.app.vault, this)
      );
      this.addCommand({
        id: "open-word-frequency-list",
        name: "Show Word Frequency List",
        callback: () => {
          this.activateView();
        }
      });
      this.injectWordFreqCss();
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  injectWordFreqCss() {
    if (document.getElementById("word-freq-hide-style"))
      return;
    const style = document.createElement("style");
    style.id = "word-freq-hide-style";
    style.textContent = `
.word-freq-table {
  margin-left: 0.2em;
}
.word-freq-row {
  display: flex;
  align-items: center;
  padding: 0.5em 0.1em 0.5em 0.1em;
  border-bottom: 1px solid var(--background-modifier-border, #ddd);
  margin-bottom: 0;
  position: relative;
  justify-content: space-between;
  cursor: pointer;
}
.word-freq-row:hover {
  background-color: var(--background-modifier-hover);
}
.word-freq-word-wrap {
  display: flex;
  align-items: center;
  min-width: 0;
  flex: 1 1 auto;
}
.word-freq-word {
  font-size: 1.08em;
  color: var(--text-normal);
  font-family: inherit;
  font-weight: 500;
  text-align: left;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  margin-right: 0.5em;
}
.word-freq-count {
  flex: none;
  min-width: 30px;
  font-size: 0.9em;
  color: var(--text-muted);
  font-family: inherit;
  font-weight: bold;
  margin-left: 1em;
  margin-right: 0.6em;
  text-align: right;
  letter-spacing: 0.01em;
}
.word-freq-hide-btn {
  opacity: 0;
  pointer-events: none;
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  outline: none !important;
  padding: 0 4px !important;
  margin-left: 0.5em;
  font-size: 0.85em;
  font-weight: 400;
  color: var(--text-faint);
  cursor: pointer;
  border-radius: 3px;
  transition: color 0.15s, opacity 0.15s, background-color 0.15s;
  display: inline;
  vertical-align: middle;
}
.word-freq-row:hover .word-freq-hide-btn {
  opacity: 0.7;
  pointer-events: auto;
}
.word-freq-hide-btn:hover {
  color: var(--text-error, #d55);
  text-decoration: underline;
  opacity: 1;
  background-color: var(--background-modifier-hover, #eee);
}

.word-freq-hidden-disclosure {
  margin-top: 2em;
}
.word-freq-hidden-disclosure summary {
  cursor: pointer;
  color: var(--text-muted);
}
.word-freq-hidden-disclosure ul {
  padding-left: 1.5em;
  list-style: none;
}
.word-freq-hidden-disclosure li {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.2em;
  color: var(--text-normal);
}

.word-freq-unhide-btn {
  opacity: 0.6;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--color-green, #2a2);
  font-size: 0.9em;
  margin-left: 0.5em;
  padding: 1px 6px;
  border-radius: 3px;
  transition: opacity 0.15s, background-color 0.15s;
}
.word-freq-unhide-btn:hover {
  opacity: 1;
  background: var(--background-modifier-success, #e5ffe5);
}

/* Styles for Word Notes View */
.word-notes-header {
  display: flex;
  align-items: center;
  margin-bottom: 1em;
}
.word-notes-back-button {
  /* Increase margin for more space */
  margin-right: 0.8em;
  cursor: pointer;
  background: none;
  border: none;
  font-size: 1.2em;
  padding: 2px 6px;
}
.word-notes-back-button:hover {
    background-color: var(--background-modifier-hover);
}
.word-notes-header h2 {
    margin: 0;
}
.word-notes-list {
    /* Remove bullets and default padding */
    list-style: none;
    padding-left: 0.2em; /* Add slight indent */
}
.word-notes-list li {
    margin-bottom: 0.5em;
    cursor: pointer;
    padding: 0.2em 0.4em;
    border-radius: 3px;
    /* Add underline to mimic link */
    text-decoration: underline;
}
.word-notes-list li:hover {
    background-color: var(--background-modifier-hover);
}

.word-notes-sort-controls {
  margin-bottom: 1em;
  display: flex;
  gap: 0.5em;
}

.word-notes-create-list-button {
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-normal);
  font-size: 0.9em;
  padding: 1px 6px;
  border-radius: 3px;
  transition: opacity 0.15s, background-color 0.15s;
}
.word-notes-create-list-button:hover {
  opacity: 1;
  background: var(--background-modifier-hover);
}
    `;
    document.head.appendChild(style);
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_WORD_FREQ);
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_WORD_NOTES);
    const style = document.getElementById("word-freq-hide-style");
    if (style)
      style.remove();
  }
  activateView() {
    return __async(this, null, function* () {
      const { workspace } = this.app;
      let leaf = workspace.getLeavesOfType(VIEW_TYPE_WORD_FREQ)[0];
      if (!leaf) {
        const newLeaf = workspace.getRightLeaf(false);
        if (!newLeaf)
          return;
        leaf = newLeaf;
        yield leaf.setViewState({
          type: VIEW_TYPE_WORD_FREQ,
          active: true
        });
      }
      workspace.revealLeaf(leaf);
    });
  }
  activateWordNotesView(word) {
    return __async(this, null, function* () {
      const { workspace } = this.app;
      let leaf = workspace.getLeavesOfType(VIEW_TYPE_WORD_NOTES)[0];
      if (!leaf) {
        const newLeaf = workspace.getRightLeaf(false);
        if (!newLeaf)
          return;
        leaf = newLeaf;
      }
      yield leaf.setViewState({ type: VIEW_TYPE_WORD_NOTES, active: true, state: { word } });
      workspace.revealLeaf(leaf);
    });
  }
};
var WordFrequencyView = class extends import_obsidian.ItemView {
  constructor(leaf, vault, plugin) {
    super(leaf);
    this.currentFreqList = [];
    this.vault = vault;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_WORD_FREQ;
  }
  getDisplayText() {
    return "Word Frequency List";
  }
  onOpen() {
    return __async(this, null, function* () {
      const container = this.contentEl;
      container.empty();
      const headerDiv = container.createEl("div", { cls: "word-freq-header" });
      headerDiv.style.display = "flex";
      headerDiv.style.justifyContent = "space-between";
      headerDiv.style.alignItems = "center";
      headerDiv.style.marginBottom = "1em";
      headerDiv.createEl("h2", { text: "Word Frequency List" });
      const moreButton = headerDiv.createEl("button", { cls: "word-freq-more-button" });
      moreButton.innerHTML = "\u2022\u2022\u2022";
      moreButton.style.background = "transparent";
      moreButton.style.border = "none";
      moreButton.style.cursor = "pointer";
      moreButton.style.fontSize = "16px";
      moreButton.style.padding = "4px 8px";
      moreButton.style.borderRadius = "4px";
      moreButton.style.transition = "background-color 0.2s ease";
      moreButton.addEventListener("mouseover", () => {
        moreButton.style.backgroundColor = "var(--background-modifier-hover)";
      });
      moreButton.addEventListener("mouseout", () => {
        moreButton.style.backgroundColor = "transparent";
      });
      moreButton.addEventListener("click", (event) => {
        const menu = new import_obsidian.Menu();
        menu.addItem((item) => {
          item.setTitle("Reload").setIcon("refresh-cw").onClick(() => __async(this, null, function* () {
            console.log("Reload clicked");
            new import_obsidian.Notice("Reloading word frequency list...");
            yield this.renderWordFrequencyList(container);
          }));
        });
        menu.addItem((item) => {
          item.setTitle("Save as note").setIcon("save").onClick(() => __async(this, null, function* () {
            console.log("Save as note clicked");
            yield this.saveListAsNote();
          }));
        });
        menu.addItem((item) => {
          item.setTitle("Reset hidden words").setIcon("eraser").onClick(() => __async(this, null, function* () {
            console.log("Reset hidden words clicked");
            if (this.plugin.settings.hiddenWords.length > 0) {
              this.plugin.settings.hiddenWords = [];
              yield this.plugin.saveSettings();
              new import_obsidian.Notice("Hidden words have been reset.");
              yield this.renderWordFrequencyList(container);
            } else {
              new import_obsidian.Notice("No words are currently hidden.");
            }
          }));
        });
        menu.showAtMouseEvent(event);
      });
      yield this.renderWordFrequencyList(container);
    });
  }
  renderWordFrequencyList(container) {
    return __async(this, null, function* () {
      const oldTable = container.querySelector(".word-freq-table");
      if (oldTable)
        oldTable.remove();
      const oldDisclosure = container.querySelector("details.word-freq-hidden-disclosure");
      if (oldDisclosure)
        oldDisclosure.remove();
      this.currentFreqList = yield this.computeWordFrequencies();
      const hiddenWords = this.plugin.settings.hiddenWords;
      const visibleList = this.currentFreqList.filter(([word]) => !hiddenWords.includes(word));
      const table = container.createEl("div", { cls: "word-freq-table" });
      for (const [word, count] of visibleList) {
        const row = table.createEl("div", { cls: "word-freq-row" });
        row.onclick = () => __async(this, null, function* () {
          yield this.plugin.activateWordNotesView(word);
        });
        const wordWrap = row.createEl("span", { cls: "word-freq-word-wrap" });
        const wordSpan = wordWrap.createEl("span", { cls: "word-freq-word" });
        wordSpan.innerText = word;
        const hideBtn = wordWrap.createEl("button", { cls: "word-freq-hide-btn" });
        hideBtn.innerText = "hide";
        hideBtn.title = "Hide this word";
        hideBtn.onclick = (e) => __async(this, null, function* () {
          e.stopPropagation();
          if (!hiddenWords.includes(word)) {
            hiddenWords.push(word);
            yield this.plugin.saveSettings();
            yield this.renderWordFrequencyList(container);
          }
        });
        const countCell = row.createEl("span", { cls: "word-freq-count" });
        countCell.innerText = String(count);
      }
      if (hiddenWords.length > 0) {
        const disclosure = container.createEl("details", { cls: "word-freq-hidden-disclosure" });
        disclosure.style.marginTop = "2em";
        const summary = disclosure.createEl("summary");
        summary.innerText = `Hidden words (${hiddenWords.length})`;
        const hiddenList = disclosure.createEl("ul");
        const sortedHidden = [...hiddenWords].sort();
        for (const word of sortedHidden) {
          const li = hiddenList.createEl("li");
          li.style.display = "flex";
          li.style.alignItems = "center";
          li.style.justifyContent = "space-between";
          const wordSpan = li.createEl("span");
          wordSpan.setText(word);
          wordSpan.style.flex = "1";
          const unhideBtn = li.createEl("button", { cls: "word-freq-unhide-btn" });
          unhideBtn.innerText = "unhide";
          unhideBtn.title = "Unhide this word";
          unhideBtn.onclick = (e) => __async(this, null, function* () {
            e.stopPropagation();
            const idx = hiddenWords.indexOf(word);
            if (idx !== -1) {
              hiddenWords.splice(idx, 1);
              yield this.plugin.saveSettings();
              yield this.renderWordFrequencyList(container);
            }
          });
        }
      }
    });
  }
  computeWordFrequencies() {
    return __async(this, null, function* () {
      const files = this.vault.getMarkdownFiles();
      const freq = {};
      for (const file of files) {
        const content = yield this.vault.cachedRead(file);
        const words = content.match(/\b\w+\b/g);
        if (words) {
          for (const word of words) {
            const lower = word.toLowerCase();
            if (lower.length > 2) {
              freq[lower] = (freq[lower] || 0) + 1;
            }
          }
        }
      }
      return Object.entries(freq).sort((a, b) => b[1] - a[1]);
    });
  }
  saveListAsNote() {
    return __async(this, null, function* () {
      const hiddenWords = this.plugin.settings.hiddenWords;
      const visibleList = this.currentFreqList.filter(([word]) => !hiddenWords.includes(word));
      let content = "# Word Frequency List\n\n";
      content += "## Visible Words\n\n";
      if (visibleList.length > 0) {
        content += "| Word | Count |\n";
        content += "|---|---|\n";
        visibleList.forEach(([word, count]) => {
          content += `| ${word} | ${count} |
`;
        });
      } else {
        content += "_No visible words found._\n";
      }
      if (hiddenWords.length > 0) {
        content += "\n## Hidden Words\n\n";
        const sortedHidden = [...hiddenWords].sort();
        sortedHidden.forEach((word) => {
          content += `- ${word}
`;
        });
      }
      const timestamp = new Date().toISOString().slice(0, 10);
      const filename = `Word Frequency - ${timestamp}.md`;
      try {
        const existingFile = this.app.vault.getAbstractFileByPath(filename);
        if (existingFile) {
          new import_obsidian.Notice(`Note "${filename}" already exists. Overwriting.`);
          yield this.app.vault.modify(existingFile, content);
        } else {
          const newFile = yield this.app.vault.create(filename, content);
          new import_obsidian.Notice(`Word frequency list saved to "${filename}".`);
        }
      } catch (error) {
        console.error("Error saving word frequency list:", error);
        new import_obsidian.Notice("Failed to save word frequency list. Check console for details.");
      }
    });
  }
};
var WordNotesView = class extends import_obsidian.ItemView {
  constructor(leaf, vault, plugin) {
    super(leaf);
    this.selectedWord = "";
    this.filesWithWord = [];
    this.sortBy = "path";
    this.sortOrder = "asc";
    this.vault = vault;
    this.plugin = plugin;
  }
  setState(state, result) {
    return __async(this, null, function* () {
      this.selectedWord = state.word || "";
      this.sortBy = state.sortBy || "path";
      this.sortOrder = state.sortOrder || "asc";
      yield __superGet(WordNotesView.prototype, this, "setState").call(this, state, result);
      yield this.renderView();
    });
  }
  getState() {
    return { word: this.selectedWord, sortBy: this.sortBy, sortOrder: this.sortOrder };
  }
  getViewType() {
    return VIEW_TYPE_WORD_NOTES;
  }
  getDisplayText() {
    return this.selectedWord || "Word Notes";
  }
  onOpen() {
    return __async(this, null, function* () {
    });
  }
  renderView() {
    return __async(this, null, function* () {
      const container = this.contentEl;
      container.empty();
      if (!this.selectedWord) {
        container.createEl("p", { text: "No word selected." });
        return;
      }
      const headerDiv = container.createEl("div", { cls: "word-notes-header" });
      const backBtn = headerDiv.createEl("button", { cls: "word-notes-back-button", text: "\u2190", title: "Back to frequency list" });
      backBtn.onclick = () => __async(this, null, function* () {
        yield this.plugin.activateView();
      });
      headerDiv.createEl("h2", { text: this.selectedWord });
      const sortControlContainer = container.createDiv({ cls: "word-notes-sort-controls" });
      sortControlContainer.style.marginBottom = "1em";
      sortControlContainer.style.display = "flex";
      sortControlContainer.style.gap = "0.5em";
      const sortByNameButton = sortControlContainer.createEl("button");
      sortByNameButton.setText(`Sort by Name (${this.sortBy === "path" ? this.sortOrder === "asc" ? "A-Z" : "Z-A" : "A-Z"})`);
      sortByNameButton.title = "Sort by file path";
      sortByNameButton.onclick = () => __async(this, null, function* () {
        if (this.sortBy === "path") {
          this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
        } else {
          this.sortBy = "path";
          this.sortOrder = "asc";
        }
        yield this.renderView();
      });
      const sortByCreatedButton = sortControlContainer.createEl("button");
      sortByCreatedButton.setText(`Sort by Created (${this.sortBy === "created" ? this.sortOrder === "asc" ? "Oldest" : "Newest" : "Oldest"})`);
      sortByCreatedButton.title = "Sort by file creation time";
      sortByCreatedButton.onclick = () => __async(this, null, function* () {
        if (this.sortBy === "created") {
          this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
        } else {
          this.sortBy = "created";
          this.sortOrder = "asc";
        }
        yield this.renderView();
      });
      const createNoteButton = sortControlContainer.createEl("button", {
        cls: "word-notes-create-list-button",
        // Use new CSS class, remove mod-cta
        attr: { style: "margin-left: auto;" },
        // Align to the right within the flex container
        title: "Create note from list"
        // Tooltip
      });
      (0, import_obsidian.setIcon)(createNoteButton, "list-plus");
      createNoteButton.addEventListener("click", () => this.createWordListNote());
      if (this.sortBy === "path") {
        sortByNameButton.style.backgroundColor = "var(--background-modifier-hover)";
      } else if (this.sortBy === "created") {
        sortByCreatedButton.style.backgroundColor = "var(--background-modifier-hover)";
      }
      const loadingEl = container.createEl("p", { text: "Searching notes..." });
      this.filesWithWord = yield this.computeFilesWithWord();
      loadingEl.remove();
      if (this.filesWithWord.length === 0) {
        container.createEl("p", { text: `No notes found containing "${this.selectedWord}".` });
      } else {
        this.sortFiles();
        const listEl = container.createEl("ul", { cls: "word-notes-list" });
        this.filesWithWord.forEach((file) => {
          const li = listEl.createEl("li");
          li.innerText = file.path;
          li.onclick = () => __async(this, null, function* () {
            yield this.plugin.app.workspace.openLinkText(file.path, "", false);
          });
        });
      }
    });
  }
  computeFilesWithWord() {
    return __async(this, null, function* () {
      if (!this.selectedWord)
        return [];
      const results = [];
      const allFiles = this.vault.getMarkdownFiles();
      const wordRegex = new RegExp(`\\b${this.selectedWord}\\b`, "i");
      for (const file of allFiles) {
        try {
          const content = yield this.vault.cachedRead(file);
          if (content.match(wordRegex)) {
            results.push(file);
          }
        } catch (e) {
          console.error(`Word Frequency Plugin: Error reading file ${file.path}:`, e);
        }
      }
      return results.sort((a, b) => a.path.localeCompare(b.path));
    });
  }
  sortFiles() {
    this.filesWithWord.sort((a, b) => {
      let comparison = 0;
      if (this.sortBy === "path") {
        comparison = a.path.localeCompare(b.path);
      } else if (this.sortBy === "created") {
        comparison = a.stat.ctime - b.stat.ctime;
      }
      return this.sortOrder === "asc" ? comparison : -comparison;
    });
  }
  createWordListNote() {
    return __async(this, null, function* () {
      if (!this.selectedWord || !this.filesWithWord || this.filesWithWord.length === 0) {
        new import_obsidian.Notice("No word selected or no files to list.");
        return;
      }
      const title = `Word List - ${this.selectedWord}`;
      let content = `# Notes containing "${this.selectedWord}"

`;
      this.filesWithWord.forEach((file) => {
        content += `- [[${file.path}]]
`;
      });
      try {
        const filePath = `${title}.md`;
        let fileToCreate = filePath;
        let counter = 1;
        while (yield this.app.vault.adapter.exists(fileToCreate)) {
          fileToCreate = `${title} ${counter++}.md`;
        }
        const newFile = yield this.app.vault.create(
          fileToCreate,
          content
        );
        new import_obsidian.Notice(`Created note: ${newFile.basename}`);
      } catch (error) {
        console.error("Error creating word list note:", error);
        new import_obsidian.Notice("Error creating note. File might already exist or invalid characters in title.");
      }
    });
  }
};
